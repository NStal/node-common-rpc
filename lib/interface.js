// Generated by CoffeeScript 1.6.3
(function() {
  var Log, RPCInterface, RPCSession, Tunnel, events, protocol,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  require("coffee-script");

  Log = require("./log.coffee");

  Tunnel = (require("./tunnel.coffee")).Tunnel;

  protocol = require("./protocol.coffee");

  events = require("events");

  RPCSession = (function() {
    function RPCSession(name, args, callback) {
      var _this = this;
      this.ticket = parseInt(Math.random() * 1000000000);
      this.name = name;
      this.args = args;
      this.callback = function() {
        var _args;
        _args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (_this.done) {
          return;
        }
        _this.close();
        if (callback) {
          return callback.apply(_this, _args);
        }
      };
    }

    RPCSession.prototype.close = function() {
      return this.done = true;
    };

    RPCSession.prototype.serialize = function() {
      return JSON.stringify({
        name: this.name,
        args: this.args,
        ticket: this.ticket
      });
    };

    return RPCSession;

  })();

  RPCInterface = (function(_super) {
    __extends(RPCInterface, _super);

    function RPCInterface(tunnel) {
      if (!tunnel) {
        return;
      }
      this._callSessions = [];
      this._callSessionBuffers = [];
      this.timeout = 1000 * 10;
      this.setTunnel(tunnel);
    }

    RPCInterface.prototype.setTunnel = function(tunnel) {
      var _this = this;
      if (this.tunnel) {
        this.tunnel.close(true);
      }
      this.tunnel = tunnel;
      this.tunnel.on("error", function(err) {
        return Log.error("tunnel error", err);
      });
      this.tunnel.on("close", function(force) {
        if (!force) {
          return _this._tryReconnect();
        }
      });
      this.tunnel.on("ready", function() {
        _this._isReconnect = false;
        return _this._flushSessionBuffers();
      });
      if (this.tunnel.isReady) {
        this._isReconnect = false;
        this._flushSessionBuffers();
      }
      return this.tunnel.on("data", function(data) {
        var e, json;
        json = null;
        try {
          json = JSON.parse(data.toString());
        } catch (_error) {
          e = _error;
          _this.emit("error", new Error("Invalid JsonParse" + e));
          return;
        }
        return _this._handleResponse(json);
      });
    };

    RPCInterface.prototype.close = function() {
      this.isClose = true;
      if (this.tunnel) {
        this.tunnel.close(true);
      }
      return this.tunnel = null;
    };

    RPCInterface.prototype.initRemoteConfig = function(config) {
      var call, _i, _len, _ref;
      if (this.noRemoteConfig) {
        Log.log("config:no remote config,ignore recieved remote config");
        return;
      }
      _ref = config.publicCalls;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        call = _ref[_i];
        this.buildRemoteCall(call, true);
      }
      return this.emit("config");
    };

    RPCInterface.prototype.describe = function(name) {
      if (typeof this[name] === "function" && this[name].info) {
        return this[name].info;
      }
      return null;
    };

    RPCInterface.prototype._handleResponse = function(rsp) {
      var index, session, _i, _len, _ref;
      if (rsp.type === "config") {
        rsp.fromServer = true;
        this.initRemoteConfig(rsp);
        return;
      }
      _ref = this._callSessions;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        session = _ref[index];
        if (session.ticket === rsp.ticket) {
          this._callSessions.splice(index, 1);
          session.callback(rsp.error, rsp.data);
          return;
        }
      }
      Log.warn("Unexpect response ticket", rsp);
      return Log.warn("Maybe someone else is using this tunnel");
    };

    RPCInterface.prototype._removeSessionFromBuffer = function(session) {
      var index, _i, _len, _ref, _session;
      _ref = this._callSessionBuffers;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        _session = _ref[index];
        if (session === _session) {
          this._callSessionBuffers.splice(index, 1);
          return true;
        }
      }
      return false;
    };

    RPCInterface.prototype._removeSession = function(session) {
      var index, _i, _len, _ref, _session;
      _ref = this._callSessions;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        _session = _ref[index];
        if (session === _session) {
          this._callSessions.splice(index, 1);
          return true;
        }
      }
      return false;
    };

    RPCInterface.prototype._tryReconnect = function() {
      var result;
      if (this._isReconnect || !this.tunnel) {
        return;
      }
      result = this.tunnel.reconnect();
      if (!result) {
        this.clearSessionBuffers(new Error("Connection Fail"));
        this.emit("close");
      } else {
        return this._isReconnect = true;
      }
    };

    RPCInterface.prototype._flushSessionBuffers = function() {
      var session, _i, _len, _ref;
      _ref = this._callSessionBuffers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        session = _ref[_i];
        this._invokeRemoteCall(session);
      }
      return this._callSessionBuffers.length = 0;
    };

    RPCInterface.prototype.clearSessions = function(err) {
      var session, _i, _j, _len, _len1, _ref, _ref1;
      _ref = this._callSessions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        session = _ref[_i];
        session.callback(err);
      }
      _ref1 = this._callSessionBuffers;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        session = _ref1[_j];
        session.callback(err);
      }
      this._callSessionBuffers = [];
      return this._callSessions = [];
    };

    RPCInterface.prototype.buildRemoteCall = function(info, fromServer) {
      var rpc;
      console.assert(typeof info.count === "number", "invalid rpc info count");
      console.assert(info.name, "invalid rpc name");
      if (this[info.name]) {
        if (!fromServer) {
          Log.warn("duplicate remote call");
        } else {
          Log.log("reconfig from server");
        }
      }
      rpc = function() {
        var arg, args, callback, session, _i, _len;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        callback = null;
        if (args.length === info.count + 1) {
          callback = args.pop();
        } else if (args.length === info.count) {
          callback = null;
        } else {
          Log.error("Expect parameters of", info.count);
          throw new Error("Unmatched parameter");
        }
        if (callback !== null && typeof callback !== "function") {
          Log.error("Invalid Callback", callback);
          throw new Error("Invalid Callback");
        }
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          arg = args[_i];
          if (typeof arg === "function") {
            Log.error(args, arg, "can't be serializable");
            throw new Error("Unserializable Arguments");
          }
        }
        session = new RPCSession(info.name, args, callback);
        return this._invokeRemoteCall(session);
      };
      rpc.info = info;
      return this[info.name] = rpc;
    };

    RPCInterface.prototype._invokeRemoteCall = function(session) {
      var _this = this;
      setTimeout((function() {
        session.callback(new Error("Timeout"));
        _this._removeSessionFromBuffer(session);
        return _this._removeSession(session);
      }), this.timeout);
      if (!this.tunnel || !this.tunnel.isReady) {
        this._callSessionBuffers.push(session);
        return;
      }
      this._callSessions.push(session);
      return this.tunnel.write(session.serialize());
    };

    return RPCInterface;

  })(events.EventEmitter);

  RPCInterface.configTimeout = 1000 * 5;

  RPCInterface.create = function(info, callback) {
    var done, inf, tunnel, type;
    type = info.type || "ws";
    tunnel = Tunnel.create(type, info);
    inf = new RPCInterface(tunnel);
    if (info.noRemoteConfig) {
      inf.noRemoteConfig = true;
    }
    if (info.autoConfig) {
      done = false;
      inf.on("close", function() {
        if (!done) {
          done = true;
          return callback(new Error("Connection Closed"));
        }
      });
      inf.on("config", function() {
        if (!done) {
          done = true;
          return callback(null, inf);
        }
      });
      inf.on("error", function(err) {
        if (!done) {
          done = true;
          return callback(new Error(err));
        }
      });
      setTimeout((function() {
        if (!done) {
          done = true;
          return callback(new Error("Timeout"));
        }
      }), RPCInterface.configTimeout);
    }
    return inf;
  };

  exports.RPCInterface = RPCInterface;

}).call(this);
