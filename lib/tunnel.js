// Generated by CoffeeScript 1.6.3
(function() {
  var Log, Tunnel, WebSocket, WebSocketServer, WebSocketTunnel, events, ws,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  require("coffee-script");

  ws = require("ws");

  events = require("events");

  WebSocket = ws;

  WebSocketServer = ws.Server;

  Log = require("./log.coffee");

  Tunnel = (function(_super) {
    __extends(Tunnel, _super);

    function Tunnel() {
      this.isClosed = false;
      Tunnel.__super__.constructor.call(this);
    }

    return Tunnel;

  })(events.EventEmitter);

  Tunnel.create = function(type, info) {
    if (type === "ws") {
      return new WebSocketTunnel(info);
    }
    return null;
  };

  WebSocketTunnel = (function(_super) {
    __extends(WebSocketTunnel, _super);

    function WebSocketTunnel(info) {
      if (info.ws) {
        this.canReconnect = false;
        this.ws = info.ws;
      } else {
        this.host = info.host || "localhost";
        this.port = info.port || 20000;
        this.ws = new WebSocket(["ws://", this.host, ":", this.port].join(""));
        this.canReconnect = true;
      }
      this.initWebsocket();
    }

    WebSocketTunnel.prototype.initWebsocket = function() {
      var _this = this;
      if (this.ws.readyState === 0) {
        this.ws.on("open", function() {
          _this.isReady = true;
          _this.isClosed = false;
          return _this.emit("ready");
        });
      } else if (this.ws.readyState === 1) {
        this.isReady = true;
        this.isClosed = false;
      } else {
        Log.error("Init WebSocket Is Brokwn, readyState", this.ws.readyState);
        this.emit("close", false);
      }
      this.ws.on("message", function(data) {
        return _this.emit("data", data);
      });
      this.ws.on("error", function(err) {
        return _this.emit("error", err);
      });
      return this.ws.on("close", function() {
        _this.isReady = false;
        if (_this.isClosed) {
          return;
        }
        _this.isReady = false;
        _this.isClosed = true;
        return _this.close();
      });
    };

    WebSocketTunnel.prototype.toString = function() {
      if (this.ws && this.ws.readyState === 1) {
        return "Websocket(" + JSON.stringify(this.ws._socket.remoteAddress) + ")";
      } else if (!this.ws) {
        return "Websocket(null)";
      } else {
        return "Websocket(not connected)";
      }
    };

    WebSocketTunnel.prototype.write = function(data) {
      if (this.ws.readyState !== 1) {
        this.emit("error", new Error("Websocket Not Ready To Write"));
        return false;
      }
      this.ws.send(data.toString());
      return true;
    };

    WebSocketTunnel.prototype.close = function(force) {
      force = force && true || false;
      if (this.isClosed) {
        return;
      }
      if (force) {
        this.neverOpenAgain = true;
      }
      this.ws.close();
      return this.emit("close", force);
    };

    WebSocketTunnel.prototype.reconnect = function() {
      if (this.ws.readyState === 1) {
        Log.warn("reconnect open ws");
        this.ws.close();
      }
      if (this.neverOpenAgain) {
        return false;
      }
      if (this.canReconnect) {
        this.ws = null;
        this.ws = new WebSocket(["ws://", this.host, ":", this.port].join(""));
      }
      return this.canReconnect;
    };

    return WebSocketTunnel;

  })(Tunnel);

  exports.Tunnel = Tunnel;

  exports.WebSocketTunnel = WebSocketTunnel;

}).call(this);
